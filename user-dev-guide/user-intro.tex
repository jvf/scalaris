\chapter{Introduction}

\scalaris{} is a scalable, transactional, distributed key-value store based
on the peer-to-peer principle. It can be used to build scalable Web 2.0
services. The concept of \scalaris{} is quite simple: Its architecture
consists of three layers.

It provides self-management and scalability by replicating services and data
among peers. Without system interruption it scales from a few PCs to
thousands of servers. Servers can be added or removed on the fly without any
service downtime.

\definecolor{layer_bg}{RGB}{55,96,146}
\definecolor{layer_bluefont}{RGB}{31,73,128}
\begin{center}
\begin{tikzpicture}
 [pre/.style={<-,shorten <=1pt,>=stealth,semithick},
  post/.style={->,shorten >=1pt,>=stealth,semithick},
  layer/.style={rectangle,fill=layer_bg,text=white,
  drop shadow={opacity=0.4},
  minimum width=7cm,
  minimum height=1.4cm,
  align=center},
  layer_desc/.style={text width=3.5cm,align=left},
  bend angle=60]
\sffamily

  %% define the layers without text to support the fitting bounding box
  \node[layer] (tx_layer) at (0,2.7) {};
  \node[layer,below=0.2 of tx_layer, minimum height=0.8cm] (rep_layer) {};
  \node[layer,below=0.2 of rep_layer] (ov_layer) {};

  \node[draw,color=layer_bg,fit=(tx_layer) (rep_layer) (ov_layer),
        inner sep=0.3cm,drop shadow, fill=white] {};

  %% draw the layers on top
  \node[above=0.4 of tx_layer, text=layer_bg]
    {\textbf{\color{layer_bluefont}{Web 2.0 Application}}};
  \node[layer] at (0,2.7) {Transaction Layer};
  \node[layer,below=0.2 of tx_layer, minimum height=0.8cm] {Replication Layer};
  \node[layer,below=0.2 of rep_layer] {P2P Layer};

  \node[above right=0.3 and 0.9 of tx_layer]
     {\smaller layer implements~\ldots};
  \node[layer_desc,right=0.9 of tx_layer] (tx_layer_desc)
     {\smaller \ldots~strong consistency, \phantom{\ldots~}atomicity, isolation};
  \node[layer_desc,right=0.9 of rep_layer] (rep_layer_desc)
     {\smaller \ldots~availability};
  \node[layer_desc,right=0.9 of ov_layer] (ov_layer_desc)
     {\smaller \ldots~scalability};

  \node[shape=single arrow,right=0.15 of tx_layer,fill=layer_bg,
        shape border rotate=180, single arrow head extend=1.2mm,
        minimum height=0.55cm,
        minimum width=0.2cm] {};
  \node[shape=single arrow,right=0.15 of rep_layer,fill=layer_bg,
        shape border rotate=180, single arrow head extend=1.2mm,
        minimum height=0.55cm,
        minimum width=0.2cm] {};
  \node[shape=single arrow,right=0.15 of ov_layer,fill=layer_bg,
        shape border rotate=180, single arrow head extend=1.2mm,
        minimum height=0.55cm,
        minimum width=0.2cm] {};

  \node[inner sep=0, below=0.6 of ov_layer]
     {\textbf{\color{layer_bluefont}{Standard Internet Nodes for Data Storage}}};
\end{tikzpicture}
\end{center}

\scalaris{} takes care of:

\begin{itemize}
\item Fail-over
\item Data distribution
\item Replication
\item Strong consistency
\item Transactions
\end{itemize}

The \scalaris{} project was initiated by Zuse Institute Berlin and onScale
solutions and was partly funded by the EU projects Selfman, XtreemOS,
Contrail and 4CaaST. Additional information (papers, videos) can be found at
\url{http://www.zib.de/de/pvs/projekte/projektdetails/article/scalaris.html}
and \url{http://www.onscale.de/scalarix.html}.

\section{Brewer's CAP Theorem}

In distributed computing there exists the so called CAP theorem. It
basically says that there are three desirable properties for distributed
systems but one can only have any two of them.

\begin{description}
\item {Strict Consistency.} Any read operation has to return the
  result of the latest write operation on the same data item.

\item {Availability.} Items can be read and modified at any time.

\item {Partition Tolerance.} The network on which the service is
  running may split into several partitions which cannot communicate
  with each other. Later on the networks may re-join again.

  For example, a service is hosted on one machine in Seattle and one
  machine in Berlin. This service is partition tolerant if it can
  tolerate that all Internet connections over the Atlantic (and
  Pacific) are interrupted for a few hours and then get repaired.
\end{description}

The goal of \scalaris{} is to provide strict consistency and partition
tolerance. We are willing to sacrifice availability to make sure that
the stored data is always consistent. I.e. when you are running
\scalaris{} with a replication degree of 4 and the network splits into
two partitions, one partition with three replicas and one partition
with one replica, you will be able to continue to use the service only
in the larger partition. All requests in the smaller partition will
time out until the two networks merge again. Note, most other
key-value stores tend to sacrifice consistency.

\section{Scientific Background}

{\bf Basics.} The general structure of \scalaris{} is modelled after
Chord. The Chord paper~\cite{chord-sigcomm} describes the ring
structure, the routing algorithms, and basic ring maintenance.

The main routines of our Chord node are in \code{src/dht\_node.erl} and
the join protocol is implemented in \code{src/dht\_node\_join.erl} (see
also Chap.~\sieheref{chapter.join}). Our implementation of the routing
algorithms is described in more detail in Sect.~\sieheref{chapter.routing}
and the actual implementation is in \code{src/rt\_chord.erl}.

{\bf Transactions.} The most interesting part is probably the
transaction algorithms. The most current description of the algorithms
and background is in \cite{enhanced-paxos}.

The implementation consists of the paxos algorithm in \code{src/paxos} and
the transaction algorithms itself in \code{src/transactions} (see also
Chap.~\sieheref{chapter.transactions}).

{\bf Ring Maintenance.} We changed the ring maintenance algorithm in
\scalaris{}. It is not the standard Chord one, but a variation of
T-Man~\cite{t-man}. It is supposed to fix the ring structure
faster. In some situations, the standard Chord algorithm is not able
to fix the ring structure while T-Man can still fix it. For node sampling,
our implementation relies on Cyclon~\cite{cyclon}.

The T-Man implementation can be found in \code{src/rm\_tman.erl} and
the Cyclon implementation in \code{src/cyclon}.

{\bf Vivaldi Coordinates.} For some experiments, we implemented so
called Vivaldi coordinates~\cite{vivaldi}. They can be used to
estimate the network latency between arbitrary nodes.

The implementation can be found in \code{src/vivaldi.erl}.

{\bf Gossipping.} For some algorithms, we use estimates of global
information. These estimates are aggregated with the help of
gossipping techniques~\cite{gossip}.

The implementation can be found in \code{src/gossip.erl}.
